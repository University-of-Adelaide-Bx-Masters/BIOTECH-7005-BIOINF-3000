<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Yassine Souilmi (he/him/his) yassine.souilmi@adelaide.edu.au Shyamsundar Ravishankar (he/him/his) shyamsundar.ravishankar@adelaide.edu.au Bastien Llamas (he/him/his) bastien.llamas@adelaide.edu.au">

<title>BIOINF 3000 / BIOTECH 7005: Bioinformatics and Systems Modelling</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="aDNA_prac_files/libs/clipboard/clipboard.min.js"></script>
<script src="aDNA_prac_files/libs/quarto-html/quarto.js"></script>
<script src="aDNA_prac_files/libs/quarto-html/popper.min.js"></script>
<script src="aDNA_prac_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="aDNA_prac_files/libs/quarto-html/anchor.min.js"></script>
<link href="aDNA_prac_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="aDNA_prac_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="aDNA_prac_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="aDNA_prac_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="aDNA_prac_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


<link rel="stylesheet" href="aDNA_prac_files/libs/quarto-html/style.css">
</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">BIOINF 3000 / BIOTECH 7005: Bioinformatics and Systems Modelling</h1>
<p class="subtitle lead">Week 7: Ancient DNA Practical</p>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Authors</div>
    <div class="quarto-title-meta-contents">
             <p>Yassine Souilmi (he/him/his)<br>
<a href="mailto:yassine.souilmi@adelaide.edu.au">yassine.souilmi@adelaide.edu.au</a><br>
Shyamsundar Ravishankar (he/him/his)<br>
<a href="mailto:shyamsundar.ravishankar@adelaide.edu.au">shyamsundar.ravishankar@adelaide.edu.au</a><br>
Bastien Llamas (he/him/his)<br>
<a href="mailto:bastien.llamas@adelaide.edu.au">bastien.llamas@adelaide.edu.au</a> </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<div style="page-break-after: always;"></div>
<section id="introduction" class="level1">
<h1>Introduction</h1>
<p>In this practical, we are going to use unique aspects of ancient DNA (aDNA) sequencing data (fragmentation, damage, contamination) to understand the impact of laboratory procedures (type of library, damage repair) on damage patterns.</p>
<p>The data are real data from the Australian Centre for Ancient DNA, and they have been generated by extracting aDNA from dingo skeletal samples from around Australia <span class="citation" data-cites="souilmi.2024.pnas">(<a href="#ref-souilmi.2024.pnas" role="doc-biblioref">Souilmi et al. 2024</a>)</span>. The dataset we will use in this practical includes an additional set of modern dingoes from <span class="citation" data-cites="Zhang.2020.NatureCommunications">(<a href="#ref-Zhang.2020.NatureCommunications" role="doc-biblioref">Zhang et al. 2020</a>)</span>. The data represent modern and ancient dingo genetic diversity, New Guinea singing dogs, and a modern village dog from Bali (<a href="#fig-map" class="quarto-xref">Figure&nbsp;1</a>).</p>
<div id="fig-map" class="quarto-float quarto-figure quarto-figure-center anchored" data-fig-align="center">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-map-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="aDNA_prac_files/assets/Fig.1.png" class="quarto-figure quarto-figure-center figure-img" style="width:80.0%;height:80.0%">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-map-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1: This is Fig. 1 of <span class="citation" data-cites="souilmi.2024.pnas">Souilmi et al. (<a href="#ref-souilmi.2024.pnas" role="doc-biblioref">2024</a>)</span> representing the geographic and temporal distribution of dingo samples. Approximate locations of the modern and ancient dingo samples with new genome-wide data presented in this study are shown on the map (ancient dingoes = blue and orange triangles, modern K’gari dingoes = bordered yellow circles). Yellow, blue, and red circles and diamonds (without black borders) represent the source localities for previously published data modern dingoes and New Guinea singing dogs. Broadly, dingoes are divided into two major populations in the “north west” (blue shades) and the “south east” (orange/yellow); the dotted line roughly indicates the transition between these two populations (based on data from mtDNA, Y-chromosome haplotypes, genome-wide SNPs, morphometric data, and environmental barriers). (Inset) estimated age of samples (median; years B.P./cal. years B.P.) for which new genome-wide data are presented in this study.
</figcaption>
</figure>
</div>
<p>After aDNA extraction, we built several types of sequencing libraries with variable damage repair, which we will explore later. For a subset of the samples, we then performed in-solution enrichment of mitochondrial genome sequences using predesigned oligonucleotides as molecular ‘baits’. The libraries enriched for mitochondrial DNA fragments were then sent to a sequencing service provider.</p>
<p>You now have access to fastq files generated by Illumina machines. The samples were sequenced in 2 x 150 sequencing—i.e.&nbsp;the machine will sequence 150 nucleotides from the start of the DNA molecules, and 150 nucleotides from the end of the same molecules (<a href="#fig-paired-end" class="quarto-xref">Figure&nbsp;2</a>).</p>
<div id="fig-paired-end" class="quarto-float quarto-figure quarto-figure-center anchored" data-fig-align="center">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-paired-end-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="aDNA_prac_files/assets/paired-end-adna-lib_update.png" class="img-fluid quarto-figure quarto-figure-center figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-paired-end-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;2: A sequencing library molecule is made of an insert (an ancient DNA fragment) flanked by sequencing adapters. In this particular experiment, each individual library is identified by a unique combination of 8-mer indexes embedded into the adapters to allow for demultiplexing (i.e. to divide sequencing reads into separate files for each sample, which have unique index combinations). The library molecules are sequenced in four steps. First, sequencing starts from one end of the library molecules and goes for 150 nucleotides (Read 1). Second, the right index is sequenced. Third, sequencing starts from the other end and also goes for 150 nucleotides (Read 2). Fourth, the left index is sequenced. Because ancient DNA inserts are short, sequencing outputs (a.k.a “reads”) are likely to contain the insert as well as some adapter and index sequences, if not all of the adapter sequences.
</figcaption>
</figure>
</div>
<div style="page-break-after: always;"></div>
</section>
<section id="referesher-on-loops-in-bash" class="level1">
<h1>0. Refresher on loops in Bash</h1>
<p>A <code>for</code> loop is a structure that allows you to repeat a set of commands for each item in a list. The syntax is as follows:</p>
<pre class="{bash}"><code>for item in list; do
  # do things to the item
done  </code></pre>
<section id="example" class="level4">
<h4 class="anchored" data-anchor-id="example">Example:</h4>
<p>Let's do some setting up first…</p>
<pre class="{bash}"><code>mkdir -p ~/Prac10/loops

cd ~/Prac10/loops

# First lets create the files
for i in $(seq 1 20) ; do
  echo $i &gt; file${i}.txt
done

ls</code></pre>
<p>Say we have 3 files <code>file1.txt</code>, <code>file2.txt</code> and <code>file3.txt</code>. We can print the files as:</p>
<pre class="{bash}"><code>for i in file1.txt file2.txt file3.txt ; do
  echo $i
done

# lets print the name of the file without .txt
for i in file1.txt file2.txt file3.txt ; do
  basename $i .txt
done

# can use *.txt instead of typing all files
for i in *txt ; do
  basename $i .txt
done

# lets rename all the files from file1.txt to file1_newer_and_cooler.txt
for i in *txt ; do
  name=$(basename $i .txt)
  new_name="${name}_newer_and_cooler.txt"  
  mv ${i} ${new_name}
done

ls</code></pre>
<p>In this prac, we will be using <code>for</code> loops to run the same command on multiple files/samples.</p>
</section>
</section>
<section id="data-preparation" class="level1">
<h1>1. Data preparation</h1>
<p>Below we describe some of the basic steps to process high throughput sequencing data in ancient DNA research. These steps were covered in Week 6 of this course under ‘Alignment/NGS’. See below for a refresher and also learn about the extra steps needed to handle ancient DNA sequence data.</p>
<section id="setting-up" class="level3">
<h3 class="anchored" data-anchor-id="setting-up">Setting up</h3>
<p>Set up working directories, input data and software environment.</p>
<pre class="{bash}"><code># make the required directories
mkdir -p ~/Prac10/{rmdups,mapdamage,trim_bam,fasta,msa}

# Change directory into Prac10
cd ~/Prac10/

# Copy the input data
<!-- FIXME: The data folder is not located in the home directory. The correct path is /shared/data/ancient_dna/data.tar.gz. -->
cp -r ~/data/ancient_dna/data.tar.gz ~/Prac10/

# Uncompress the data for the prac
tar -xvf data.tar.gz

# make some space
rm data.tar.gz

# Activate the software environment
<!-- FIXME: The conda environment adna does not exist. Might need to verify the environment name or create it.-->
conda activate adna</code></pre>
</section>
<section id="the-raw-sequencing-data" class="level2">
<h2 class="anchored" data-anchor-id="the-raw-sequencing-data">1.1. The raw sequencing data</h2>
<p>The raw sequencing data are called “reads”, and they are in a FASTQ format. More information about this particular data format can be found at <a href="https://en.wikipedia.org/wiki/FASTQ_format">https://en.wikipedia.org/wiki/FASTQ_format</a>.</p>
<p>Briefly, the FASTQ format uses four lines per sequence:</p>
<ul>
<li>Line 1 always begins with @. It contains a sequence identifier generated by the sequencing machine and a description (optional).</li>
<li>Line 2 is the raw sequence (or “read”).</li>
<li>Line 3 always begins with +. It usually does not contain any other information.</li>
<li>Line 4 encodes the quality scores for the sequence in Line 2.</li>
</ul>
<p>An example of your raw FASTQ data looks like:</p>
<pre><code>
@HWI-ST1359:56:C4EE8ACXX:6:1101:8215:1988 1:N:0:CCGGTAC 
TAGCTAATTGAGATGGAAGAGCACACGTCTGAACTCCAGTCACCCGGTACATCTCGTATGCCGTCTTCTGCTTGAAAAAAAAAACAAAAACAACACAACAC 
+ 
CCCFFFFFHHHHHJJJJJJJJJJJJJJJJJJJJJJIJJJGHHIJJJIHHIHHJJJJJIJJJJGHFFFFECECECCCCDDD##################### 
@HWI-ST1359:56:C4EE8ACXX:6:1101:8082:1996 1:N:0:CCGGTAC 
GTGGATCCTATCGGTTCTCGACTCGCTTCAGATCTACTTTGAATCTACTTTAGATCTATCGTAACGACTTAACTCGGAGATCGGAAGAGCACACGTCTGAA 
+ 
CCCFFFFFHHHHHJJJJJJJJJJJJJIIIIJJJJJJJJJJIJJJJJJJJJJIIJJJJJJJJJIIIHHHFFFFEEDDDDDDDCDDDBDDBDDDDDDDDDDDA 
@HWI-ST1359:56:C4EE8ACXX:6:1101:8352:1972 1:N:0:CCGGTAC 
NTCTCCGATGCGTATCCAATGGGGAATCATCATACTACCACACGATGCACATATGAGATAGATGAGATCGGAAGCACACGTCTGAACTCCAGTCACCCGGT 
+ 
#4=DFFFFHHHHFHJJJJJJJJJJJJIIJJJJJJJJJJJJJIJJJJJJIJJIJJJJJJJJJHHFGEHEFEFDDDDACCABABDDDDDDDD@@ACCDDDDD0 
@HWI-ST1359:56:C4EE8ACXX:6:1101:8415:1994 1:N:0:CCGGTAC 
ATACGGTCATCGGGCGATCAGCTAGTCCTTTCTCGTTCGACTTTCGTACAGATGAGATCGGAAGAGCACACGTCTGAACTCCAGTCACCCGGTACATCTCG 
+ 
CCCFFFDFHHHHHIIJJIJJJJIJJFHJIJJJJJGHJHIIJJJJJIHHIHHHGHFFFFEFDDDDD@DCDDDBBDDBCCDDDDDDDDCDCDB559BCBACDA  
</code></pre>
</section>
<section id="quality-control-of-sequenced-reads" class="level2">
<h2 class="anchored" data-anchor-id="quality-control-of-sequenced-reads">1.2. Quality control of sequenced reads</h2>
<p>The first thing you do when you receive sequencing data is perform a quality control. The programs <a href="https://github.com/OpenGene/fastp">fastp</a> <span class="citation" data-cites="Chen.2018.Bioinformatics">(<a href="#ref-Chen.2018.Bioinformatics" role="doc-biblioref">Chen et al. 2018</a>)</span> and <a href="https://www.bioinformatics.babraham.ac.uk/projects/fastqc/">fastqc</a> <span class="citation" data-cites="andrews2012">(<a href="#ref-andrews2012" role="doc-biblioref">Andrews et al. 2012</a>)</span> are very easy to use and produce html reports that can be visualised in any internet browser. We have already run <code>fastp</code> for all the samples. Let’s look at the html reports for samples <code>D01_W0235</code> and <code>A19053</code>. The data can be found in <code>data/fastp/</code></p>
<blockquote class="blockquote">
<p><strong>Q1:</strong> What can you say about the difference in read-length?</p>
</blockquote>
<blockquote class="blockquote">
<p><strong>Q2:</strong> What about the duplication rate? What can you conclude from that?</p>
</blockquote>
</section>
<section id="read-collapsing" class="level2">
<h2 class="anchored" data-anchor-id="read-collapsing">1.3. Read collapsing</h2>
<p>Ancient DNA molecules are typically less than 100 bp in length, meaning the 150-base-long reads may include some of the sequencing adapter and index sequences (Figure 2). It is therefore necessary to trim the adapter/index sequences from the data in order to only analyse the inserts.</p>
<p>Typically, more than 95% of the read pairs (Read 1 and Read 2) can be collapsed in ancient DNA datasets because the short insert DNA ends up being sequenced twice in both Read 1 and Read 2.</p>
<p>A program has been developed for ancient DNA, where the adapter/index sequences are trimmed, and the overlapping reads are merged together (or collapsed). The program is <a href="https://github.com/MikkelSchubert/adapterremoval">AdapterRemoval</a> <span class="citation" data-cites="Lindgreen.2012.BMC">(<a href="#ref-Lindgreen.2012.BMC" role="doc-biblioref">Lindgreen 2012</a>)</span>.</p>
<p>We have also run this already in order to save time and get to the exciting parts of ancient DNA analysis. <code>AdapterRemoval</code> produces metrics that we can use in <code>MultiQC</code> to summarise.</p>
<p><a href="https://multiqc.info/">MultiQC</a> <span class="citation" data-cites="Ewels.2016.bioinformatics">(<a href="#ref-Ewels.2016.bioinformatics" role="doc-biblioref">Ewels et al. 2016</a>)</span> is a very useful tool that can combine quality-control reports from multiple samples.</p>
<pre class="{bash}"><code>## Activate the bioinf environment. It has MultiQC
conda activate bioinf

cd ~/Prac10/data/adapterremoval/

# combine the reports using multiqc
multiqc .</code></pre>
<p>open the <code>multiqc_report.html</code>.</p>
<blockquote class="blockquote">
<p><strong>Q3:</strong> What do you notice from the report?</p>
</blockquote>
<blockquote class="blockquote">
<p><strong>Q4:</strong> What can you say about the ratio of collapsed reads?</p>
</blockquote>
<blockquote class="blockquote">
<p><strong>Q5:</strong> What can you learn from the read length?</p>
</blockquote>
</section>
<section id="read-alignment" class="level2">
<h2 class="anchored" data-anchor-id="read-alignment">2. Read alignment</h2>
<p>Now we will align the sequencing reads to the dog mitochondrial reference genome. We downloaded the reference genome from ENSEMBL database <span class="citation" data-cites="ensembl">(<a href="#ref-ensembl" role="doc-biblioref">Birney and Team 2003</a>)</span>, a genomic database containing several useful resources. For convenience, you can find the indexed reference inside <code>data/reference</code>.</p>
<section id="alignment" class="level3">
<h3 class="anchored" data-anchor-id="alignment">2.1. Alignment</h3>
<p>We use bwa aln alignment <span class="citation" data-cites="Li.2009.Bioinformatics.bwa">(<a href="#ref-Li.2009.Bioinformatics.bwa" role="doc-biblioref">Li and Durbin 2009</a>)</span> according to the parameters in <span class="citation" data-cites="Oliva.2021.Briefings">Oliva et al. (<a href="#ref-Oliva.2021.Briefings" role="doc-biblioref">2021</a>)</span>. These parameters have been tuned to deliver optimal performance for aDNA samples. Again to save time, we have aligned the samples for you already (it is similar to alignment in Week 6). Additionally, these reads have been sorted using <a href="https://www.htslib.org/">samtools</a> <span class="citation" data-cites="Li.2009.samtools">(<a href="#ref-Li.2009.samtools" role="doc-biblioref">Li et al. 2009</a>)</span>.</p>
</section>
</section>
<section id="removing-duplicate-reads" class="level2">
<h2 class="anchored" data-anchor-id="removing-duplicate-reads">3. Removing duplicate reads</h2>
<p>When sequencing libraries are built from extracted DNA, PCR amplification is often used to increase the amount of DNA available for sequencing. This is especially critical in aDNA studies, where the DNA of interest is highly degraded and present in very low amounts. However, PCR amplification can introduce an issue: the same DNA fragment may be copied and sequenced multiple times.</p>
<p>These duplicate sequences artificially inflate the representation of certain alleles or regions, skewing downstream analyses. For instance, if the same fragment is sequenced multiple times, it might appear that a particular allele is more common than it actually is. To avoid this bias, it is standard practice to detect and mark duplicated sequences in the data.</p>
<p>Duplicate marking works by identifying reads that map to the exact same location in the genome, meaning they have the same start coordinate. Since the sequencing process is random, it is highly unlikely for independent reads to start at the exact same position unless they originate from the same DNA molecule. Therefore, reads that share the same start point are flagged as duplicates and can be removed from further analysis to ensure more accurate results.</p>
<section id="markduplicates" class="level3">
<h3 class="anchored" data-anchor-id="markduplicates">3.1 MarkDuplicates</h3>
<p>We will use a tool called <a href="http://broadinstitute.github.io/picard/">MarkDuplicates</a> <span class="citation" data-cites="Picard2018toolkit">(<a href="#ref-Picard2018toolkit" role="doc-biblioref">Broad Institute, n.d.</a>)</span> which is part of the Picard suite of tools. Picard is a toolkit to manipulate mapped sequence data.</p>
<pre class="{bash}"><code># Lets reactivate adna environment
<!-- FIXME: The conda environment adna does not exist. Might need to verify the environment name or create it.-->
conda activate adna

cd ~/Prac10/rmdups/

for bam in ../data/alignment/*bam; do
  sn=$(basename $bam .sorted.bam)
  picard MarkDuplicates INPUT=$bam \
    OUTPUT=${sn}_rmdup.bam REMOVE_DUPLICATES=TRUE \
    AS=TRUE METRICS_FILE="${sn}_rmdup.metrics" \
    VALIDATION_STRINGENCY=SILENT
  samtools index ${sn}_rmdup.bam
done</code></pre>
</section>
</section>
<section id="read-damage" class="level2">
<h2 class="anchored" data-anchor-id="read-damage">4. Read damage</h2>
<p>We are interested in the characteristic post-mortem damage that can be detected in ancient DNA, i.e. the deamination of C into U, which will be amplified and sequenced as T. Deamination of C occurs primarily at the extremities of ancient DNA molecules, and the resulting 5’ C-to-T substitutions (and complementary 3’ G-to-A substitutions) can be summarised using the program mapDamage (<a href="#fig-mapdamage" class="quarto-xref">Figure&nbsp;3</a>).</p>
<p>We will use the <a href="https://ginolhac.github.io/mapDamage/">mapDamage</a> package <span class="citation" data-cites="Jónsson.2013.Bioinformatics">(<a href="#ref-Jónsson.2013.Bioinformatics" role="doc-biblioref">Jónsson et al. 2013</a>)</span> to capture the misincorporation rate and location within the reads.</p>
<div id="fig-mapdamage" class="quarto-float quarto-figure quarto-figure-center anchored" data-fig-align="center">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-mapdamage-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="aDNA_prac_files/assets/E522_Fragmisincorporation_plot_small.png" class="quarto-figure quarto-figure-center figure-img" style="width:70.0%;height:70.0%">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-mapdamage-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;3: Fragment misincorporations as predicted by mapDamage. Notice the ‘smiley’-like pattern characteristic of aDNA restulting from excess C&gt;T transitions in the 5’ end, and excess G&gt;A transitions in the 3’ end.
</figcaption>
</figure>
</div>
<p>Lets run mapDamage on a few samples and check the results.</p>
<pre class="{bash}"><code>cd ~/Prac10/mapdamage/
ref="../data/reference/dog_mtDNA.fasta"
 <!-- FIXME: Unable to run this command due to the error: KeyError: "tag 'RG' not present". This can likely be fixed by ensuring the read group (`RG`) tag is properly added during the `bwa` alignment step. -->
for bam in ../rmdups/{D10,D11,D12,D13,Y47,BaliVD}*rmdup.bam; do
  mapDamage -i $bam -r $ref --no-stats
done</code></pre>
<blockquote class="blockquote">
<p><strong>Q6:</strong> What samples do you think are ancient?</p>
</blockquote>
<blockquote class="blockquote">
<p><strong>Q7:</strong> What do you notice about the fragment length of the ancient and modern samples?</p>
</blockquote>
</section>
<section id="trimming-the-damaged-reads" class="level2">
<h2 class="anchored" data-anchor-id="trimming-the-damaged-reads">5. Trimming the damaged reads</h2>
<p>To mitigate the impact of aDNA damage, it is necessary to trim the damaged bases from the ends of reads before further processing. This ensures that damage does not falsely influence variant calling or other analyses.</p>
<p>In this practical session, for the sake of simplicity and uniformity, we will trim two bases from both the 5’ and 3’ ends of every read, regardless of whether the sample is modern or ancient. However, in real-world scenarios, this step is typically only applied to aDNA samples where damage is observed, and the extent of trimming is determined by the damage patterns seen in mapDamage results.</p>
<p>We will be using a tool called <code>trimBam</code> from <a href="https://genome.sph.umich.edu/wiki/BamUtil">BamUtil</a> <span class="citation" data-cites="jun_efficient_2015">(<a href="#ref-jun_efficient_2015" role="doc-biblioref">Jun et al. 2015</a>)</span></p>
<blockquote class="blockquote">
<p><strong>Q8:</strong> Based on the mapDamage plot how many bases should we trim?</p>
</blockquote>
<pre class="{bash}"><code>cd ~/Prac10/trim_bam

for bam in ../rmdups/*rmdup.bam; do
 bam trimBam $bam tmp.bam -L 2 -R 2
 samtools sort  tmp.bam -o $(basename $bam _rmdup.bam).trimmed.bam
 samtools index $(basename $bam _rmdup.bam).trimmed.bam
done</code></pre>
</section>
<section id="understanding-population-structure-using-the-mitochondrial-dna" class="level2">
<h2 class="anchored" data-anchor-id="understanding-population-structure-using-the-mitochondrial-dna">6. Understanding population structure using mitochondrial DNA</h2>
<p>Mitochondrial DNA (mtDNA) is a uniparental marker that is maternally inherited (<a href="#fig-mt-dna" class="quarto-xref">Figure&nbsp;4</a>). It is a valuable marker to understand population history of a species. The maternal inheritance preserves a direct lineage of maternal ancestry. mtDNA are relatively small circular DNA molecules (~16 kb) that are found in high copy number within cells, which increases chances of surviving in ancient samples, making it easier to reconstruct compared to nuclear DNA. They also do not recombine and so the entire mtDNA is inherited as a single unit. Its relatively high mutation rate provides sufficient variability to distinguish between populations, track evolutionary changes, and infer migration patterns across generations. These characteristics make mtDNA a powerful marker for reconstructing ancient population dynamics.</p>
<div id="fig-mt-dna" class="quarto-float quarto-figure quarto-figure-center anchored" data-fig-align="center">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-mt-dna-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="aDNA_prac_files/assets/mtdna_med.jpeg" class="quarto-figure quarto-figure-center figure-img" style="width:70.0%;height:70.0%">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-mt-dna-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;4: Nuclear DNA is inherited from both parents while mtDNA is only maternally inherited.
</figcaption>
</figure>
</div>
<section id="create-a-concesus-mt-genome" class="level3">
<h3 class="anchored" data-anchor-id="create-a-concesus-mt-genome">6.1 Create a consensus mitochondrial genome sequence</h3>
<p>First, let's reconstruct the mitochondrial genome of our samples. We will use the <a href="https://www.htslib.org/doc/samtools-consensus.html">consensus</a> function from <code>samtools</code>. We will use the alignment file as input and get the entire mitochondrial genomes as a FASTA file. See the documentation to understand what all the options in the command below does.</p>
<pre class="{bash}"><code>cd ~/Prac10/fasta

for bam in ../trim_bam/*.trimmed.bam; do
  sn=$(basename $bam .trimmed.bam)
<!-- FIXME: Attempted to run `samtools consensus` from the `bioinfo` conda environment (I’m aware it should be run in the `adna` environment), but it only includes version 1.13. If the `adna` environment is not used, `samtools` must be updated to version >1.16 to enable the `consensus` function. -->
  samtools consensus -r chrM \
    -o ${sn}_consensus.fasta -a \
    --min-MQ 25 --min-BQ 30 -c 0.75 \
    -d 2 ${bam}

  sed -i 's/chrM/'$sn'/' ${sn}_consensus.fasta
done</code></pre>
<p>Merge all the genomes into a single FASTA file.</p>
<pre class="{bash}"><code>cd ~/Prac10/fasta

for fasta in *consensus.fasta ; do
  cat $fasta
done &gt; concatenated.fasta</code></pre>
</section>
<section id="perform-multiple-sequence-alignment" class="level3">
<h3 class="anchored" data-anchor-id="perform-multiple-sequence-alignment">6.2 Perform multiple sequence alignment</h3>
<p>We then want to compare how the mitochondrial genomes across our samples compare to each other. For this we will use the tool <a href="https://mafft.cbrc.jp/alignment/software/">mafft</a> <span class="citation" data-cites="mafft">(<a href="#ref-mafft" role="doc-biblioref">Katoh et al. 2002</a>)</span> that can perform multiple sequence alignment (MSA).</p>
<pre class="{bash}"><code>conda activate bioinf

# mafft multiple alignment
mafft concatenated.fasta &gt; aligned.fasta</code></pre>
</section>
<section id="convert-msa-to-nexus" class="level3">
<h3 class="anchored" data-anchor-id="convert-msa-to-nexus">6.3 Convert MSA to Nexus</h3>
<p>Finally, we will convert the MSA to Nexus format to make it compatible for tools that allow to visualise the multiple alignment. Nexus is a useful format that can store information about the alignment as well as metadata about the samples such as geographical origin. We will use <a href="https://github.com/yulab-smu/seqmagick">seqmagick</a> <span class="citation" data-cites="seqmagick">(<a href="#ref-seqmagick" role="doc-biblioref">Yu 2024</a>)</span> for this.</p>
<pre class="{bash}"><code># seqmagick conversion
seqmagick convert --alphabet dna aligned.fasta aligned.nex</code></pre>
</section>
<section id="visualise-structure-in-popart" class="level3">
<h3 class="anchored" data-anchor-id="visualise-structure-in-popart">6.4 Visualise structure in PopART</h3>
<p>Before visualising the multiple alignment we need to add metadata about our samples to the Nexus file.</p>
<pre class="{bash}"><code>cat aligned.nex ~/data/ancient_dna/traits.nex &gt; aligned_traits.nex</code></pre>
<p>We can use <a href="https://popart.maths.otago.ac.nz/download/">PopART (Population Analysis with Reticulate Trees)</a> <span class="citation" data-cites="leigh_popart_2015">(<a href="#ref-leigh_popart_2015" role="doc-biblioref">Leigh and Bryant 2015</a>)</span> to create a median-joining network <span class="citation" data-cites="bandelt_median-joining_1999">(<a href="#ref-bandelt_median-joining_1999" role="doc-biblioref">Bandelt, Forster, and Röhl 1999</a>)</span>. This is a tool to visualise the differences between mitochondrial sequences. It clusters similar sequences together and calculates the number of differences between dissimilar sequences.</p>
<p>Unfortunately, PopART does not have a command line tool. You will have to run PopART on your local computer. It is free to use and can be downloaded from <a href="https://popart.maths.otago.ac.nz/download/">here</a>.</p>
<p>Once you have installed PopART, follow the instructions below.</p>
<p><img src="aDNA_prac_files/assets/LoadNexus.png" id="fig-loadnexus" class="quarto-figure quarto-figure-center anchored" style="width:70.0%;height:70.0%" alt="Load Nexus file into PopArt"> <img src="aDNA_prac_files/assets/MaskSites.png" id="fig-removesite" class="quarto-figure quarto-figure-center anchored" style="width:70.0%;height:70.0%" alt="Remove sites with missing data"> <img src="aDNA_prac_files/assets/RemoveSamples.png" id="fig-removesamples" class="quarto-figure quarto-figure-center anchored" style="width:70.0%;height:70.0%" alt="Remove samples with missing data"> <img src="aDNA_prac_files/assets/MedianJoiningNetwork.png" id="fig-mjn" class="quarto-figure quarto-figure-center anchored" style="width:70.0%;height:70.0%" alt="Create a Medium-Joining Network"></p>
<p>We should be able to create something like this. <img src="aDNA_prac_files/assets/aligned_mafft_traits.png" id="fig-mjn" class="quarto-figure quarto-figure-center anchored" style="width:70.0%;height:70.0%" alt="A Medium-Joining Network with ancient and modern Dingoes, as well as New Guinea Singing dogs and Bali Village Dog"></p>
<blockquote class="blockquote">
<p><strong>Q9:</strong> What can you infer about the population structure of dingoes?</p>
</blockquote>
</section>
<section id="references" class="level3">
<h3 class="anchored" data-anchor-id="references">References</h3>
<div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-andrews2012" class="csl-entry" role="listitem">
Andrews, Simon, Felix Krueger, Anne Segonds-Pichon, Laura Biggins, Christel Krueger, and Steven Wingett. 2012. <span>“<span>FastQC</span>.”</span> <span>Babraham, UK</span>: Babraham Institute.
</div>
<div id="ref-bandelt_median-joining_1999" class="csl-entry" role="listitem">
Bandelt, H. J., P. Forster, and A. Röhl. 1999. <span>“Median-Joining Networks for Inferring Intraspecific Phylogenies.”</span> <em>Molecular Biology and Evolution</em> 16 (1): 37–48. <a href="https://doi.org/10.1093/oxfordjournals.molbev.a026036">https://doi.org/10.1093/oxfordjournals.molbev.a026036</a>.
</div>
<div id="ref-ensembl" class="csl-entry" role="listitem">
Birney, E, and Ensembl Team. 2003. <span>“<span class="nocase">Ensembl: a genome infrastructure.</span>”</span> <em>Cold Spring Harbor Symposia on Quantitative Biology</em> 68 (0): 213–15. <a href="https://doi.org/10.1101/sqb.2003.68.213">https://doi.org/10.1101/sqb.2003.68.213</a>.
</div>
<div id="ref-Picard2018toolkit" class="csl-entry" role="listitem">
Broad Institute. n.d. <span>“Picard Tools.”</span><em><span> Broad Institute, GitHub Repository</span></em>. <a href="http://broadinstitute.github.io/picard/" class="uri">http://broadinstitute.github.io/picard/</a>.
</div>
<div id="ref-Chen.2018.Bioinformatics" class="csl-entry" role="listitem">
Chen, Shifu, Yanqing Zhou, Yaru Chen, and Jia Gu. 2018. <span>“<span class="nocase">fastp: an ultra-fast all-in-one FASTQ preprocessor</span>.”</span> <em>Bioinformatics</em> 34 (17): i884–90. <a href="https://doi.org/10.1093/bioinformatics/bty560">https://doi.org/10.1093/bioinformatics/bty560</a>.
</div>
<div id="ref-Ewels.2016.bioinformatics" class="csl-entry" role="listitem">
Ewels, Philip, Måns Magnusson, Sverker Lundin, and Max Käller. 2016. <span>“<span class="nocase">MultiQC: summarize analysis results for multiple tools and samples in a single report</span>.”</span> <em>Bioinformatics</em> 32 (19): 3047–48. <a href="https://doi.org/10.1093/bioinformatics/btw354">https://doi.org/10.1093/bioinformatics/btw354</a>.
</div>
<div id="ref-Jónsson.2013.Bioinformatics" class="csl-entry" role="listitem">
Jónsson, Hákon, Aurélien Ginolhac, Mikkel Schubert, Philip L. F. Johnson, and Ludovic Orlando. 2013. <span>“<span class="nocase">mapDamage2.0: fast approximate Bayesian estimates of ancient DNA damage parameters</span>.”</span> <em>Bioinformatics</em> 29 (13): 1682–84. <a href="https://doi.org/10.1093/bioinformatics/btt193">https://doi.org/10.1093/bioinformatics/btt193</a>.
</div>
<div id="ref-jun_efficient_2015" class="csl-entry" role="listitem">
Jun, Goo, Mary Kate Wing, Gonçalo R. Abecasis, and Hyun Min Kang. 2015. <span>“An Efficient and Scalable Analysis Framework for Variant Extraction and Refinement from Population Scale <span>DNA</span> Sequence Data.”</span> <em>Genome Research</em>, April, gr.176552.114. <a href="https://doi.org/10.1101/gr.176552.114">https://doi.org/10.1101/gr.176552.114</a>.
</div>
<div id="ref-mafft" class="csl-entry" role="listitem">
Katoh, Kazutaka, Kazuharu Misawa, Kei‐ichi Kuma, and Takashi Miyata. 2002. <span>“<span class="nocase">MAFFT: a novel method for rapid multiple sequence alignment based on fast Fourier transform</span>.”</span> <em>Nucleic Acids Research</em> 30 (14): 3059–66. <a href="https://doi.org/10.1093/nar/gkf436">https://doi.org/10.1093/nar/gkf436</a>.
</div>
<div id="ref-leigh_popart_2015" class="csl-entry" role="listitem">
Leigh, Jessica W., and David Bryant. 2015. <span>“Popart: Full-Feature Software for Haplotype Network Construction.”</span> <em>Methods in Ecology and Evolution</em> 6 (9): 1110–16. <a href="https://doi.org/10.1111/2041-210X.12410">https://doi.org/10.1111/2041-210X.12410</a>.
</div>
<div id="ref-Li.2009.Bioinformatics.bwa" class="csl-entry" role="listitem">
Li, Heng, and Richard Durbin. 2009. <span>“<span class="nocase">Fast and accurate short read alignment with Burrows–Wheeler transform</span>.”</span> <em>Bioinformatics</em> 25 (14): 1754–60. <a href="https://doi.org/10.1093/bioinformatics/btp324">https://doi.org/10.1093/bioinformatics/btp324</a>.
</div>
<div id="ref-Li.2009.samtools" class="csl-entry" role="listitem">
Li, Heng, Bob Handsaker, Alec Wysoker, Tim Fennell, Jue Ruan, Nils Homer, Gabor Marth, Goncalo Abecasis, Richard Durbin, and 1000 Genome Project Data Processing Subgroup. 2009. <span>“<span class="nocase">The Sequence Alignment/Map format and SAMtools</span>.”</span> <em>Bioinformatics</em> 25 (16): 2078–79. <a href="https://doi.org/10.1093/bioinformatics/btp352">https://doi.org/10.1093/bioinformatics/btp352</a>.
</div>
<div id="ref-Lindgreen.2012.BMC" class="csl-entry" role="listitem">
Lindgreen, Stinus. 2012. <span>“<span class="nocase">AdapterRemoval: easy cleaning of next-generation sequencing reads</span>.”</span> <em>BMC Research Notes</em> 5 (1): 337. <a href="https://doi.org/10.1186/1756-0500-5-337">https://doi.org/10.1186/1756-0500-5-337</a>.
</div>
<div id="ref-Oliva.2021.Briefings" class="csl-entry" role="listitem">
Oliva, Adrien, Raymond Tobler, Alan Cooper, Bastien Llamas, and Yassine Souilmi. 2021. <span>“<span class="nocase">Systematic benchmark of ancient DNA read mapping</span>.”</span> <em>Briefings in Bioinformatics</em> 22 (5): bbab076. <a href="https://doi.org/10.1093/bib/bbab076">https://doi.org/10.1093/bib/bbab076</a>.
</div>
<div id="ref-souilmi.2024.pnas" class="csl-entry" role="listitem">
Souilmi, Yassine, Sally Wasef, Matthew P Williams, Gabriel Conroy, Ido Bar, Pere Bover, Jackson Dann, et al. 2024. <span>“<span class="nocase">Ancient genomes reveal over two thousand years of dingo population structure</span>.”</span> <em>Proceedings of the National Academy of Sciences</em> 121 (30): e2407584121. <a href="https://doi.org/10.1073/pnas.2407584121">https://doi.org/10.1073/pnas.2407584121</a>.
</div>
<div id="ref-seqmagick" class="csl-entry" role="listitem">
Yu, Guangchuang. 2024. <em>Seqmagick: Sequence Manipulation Utilities</em>. <a href="https://github.com/yulab-smu/seqmagick">https://github.com/yulab-smu/seqmagick</a>.
</div>
<div id="ref-Zhang.2020.NatureCommunications" class="csl-entry" role="listitem">
Zhang, Shao-jie, Guo-Dong Wang, Pengcheng Ma, Liang-liang Zhang, Ting-Ting Yin, Yan-hu Liu, Newton O. Otecko, et al. 2020. <span>“<span class="nocase">Genomic regions under selection in the feralization of the dingoes</span>.”</span> <em>Nature Communications</em> 11 (1): 671. <a href="https://doi.org/10.1038/s41467-020-14515-6">https://doi.org/10.1038/s41467-020-14515-6</a>.
</div>
</div>
</section>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>
